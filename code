#include <iostream>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/i2c-dev.h>

#define BMP280_ADDRESS 0x76
#define REG_CONTROL 0xF4
#define REG_PRESS_MSB 0xF7

int main() {
    const char *device = "/dev/i2c-1";
    int file = open(device, O_RDWR);
    if (file < 0) {
        std::cerr << "Failed to open the I2C bus\n";
        return 1;
    }

    if (ioctl(file, I2C_SLAVE, BMP280_ADDRESS) < 0) {
        std::cerr << "Failed to acquire bus access or talk to slave\n";
        return 1;
    }

    // Configure the BMP280: set oversampling and mode
    char config[2] = {REG_CONTROL, 0x27};  // Normal mode, oversampling x1
    if (write(file, config, 2) != 2) {
        std::cerr << "Failed to configure the BMP280\n";
        return 1;
    }

    for (int i = 0; i < 10; i++) {
        // Wait for measurement to complete
        usleep(1000);

        // Read pressure data
        char reg = REG_PRESS_MSB;
        if (write(file, &reg, 1) != 1) {
            std::cerr << "Failed to set register pointer\n";
            return 1;
        }

        char data[6];
        if (read(file, data, 6) != 6) {
            std::cerr << "Failed to read data from BMP280\n";
            return 1;
        }

        // Combine data to calculate raw pressure
        int rawPressure = ((int)data[0] << 12) | ((int)data[1] << 4) | ((data[2] >> 4) & 0x0F);

        // Convert to hPa (you may need to refine based on calibration)
        double pressure = rawPressure / 25600.0;

        // Display the result
        std::cout << "RelevÃ© " << (i + 1) << ": Pression = " << pressure << " hPa" << std::endl;

        // Pause 2 seconds before the next measurement
        sleep(2);
    }

    close(file);
    return 0;
}
